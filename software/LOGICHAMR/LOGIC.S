 LST OFF
 XC OFF ; 6502 MODE
********************************
* LOGIC ANALYZER DISPLAY       *
********************************
*
 DSK LOGIC
 ORG $8000
 TYP $06
 JMP MAIN
*-------------------------------
* ZERO PAGES
*-------------------------------
*
PRVBIT EQU $80
CURSMPL EQU $81
TRANS EQU $82
SMPLPTR EQU $83
BUFFPTR EQU $84
CHANSAVE EQU $86
LINENUM EQU $87
TEMP EQU $90
CURCOL EQU $92
CURBIT EQU $93
CURMASK EQU $94
ACOL EQU $95
ABIT EQU $96
BCOL EQU $97
BBIT EQU $98
TXTPTR EQU $FA
SMPLBLK EQU $FB
SMPRATE EQU $FC
*
*-------------------------------
* CAPTURE STATE VARIABLES
*-------------------------------
*
TRIGCHAN EQU $9A    ; TRIGGER CHANNEL 0-7
TRIGMODE EQU $9B    ; 0=RISING, 1=FALLING
WINPRESET EQU $9C   ; WINDOW PRESET 1-4
CAPSTATE EQU $9D    ; 0=READY, 1=ARMED, 2=CAPTURED
WINSEL EQU $9E      ; WINDOW SELECT MODE FLAG
*
*-------------------------------
* NEW ZP VARIABLES FOR 80-COL UI
*-------------------------------
*
CVTPTR EQU $E2      ; 2 BYTES - CONVTIME5 TARGET PTR
PIXA EQU $E4        ; 2 BYTES - MARKER A PIXEL POS
PIXB EQU $E6        ; 2 BYTES - MARKER B PIXEL POS
*
*-------------------------------
* CONSTANTS
*-------------------------------
*
NUMCOLS EQU 38 ; COLS PER ROW
BASELINE EQU 0 ; STARTING LINE FOR CHAN 0
*
*-------------------------------
* UTILITIES                    *
*-------------------------------
*
 PUT INCLUDE ; INCLUDE DRAW UTILS
BELL EQU $FF3A
*
*-------------------------------
* MACROS                       *
*-------------------------------
*-------------------------------
* FILLBUF - READ SAMPLES FROM FPGA
*-------------------------------
* IN:  Y = CHANNEL NUMBER (0-7)
* OUT: TMPBUF FILLED WITH 38 SAMPLES
* CLOBBERS: A, X
* PRESERVES: Y
*-------------------------------
* FPGA REGISTERS:
*   $C0C0 = CHANNEL SELECT
*   $C0C1 = SAMPLE ADDRESS
*   $C0C2 = DATA OUT
*   $C0C3 = COMMAND (2=READ)
*   $C0C4 = STATUS (BIT0=BUSY)
*   $C0C5 = STRETCH FACTOR
*   $C0C6 = TRIGGER CHANNEL
*   $C0C7 = TRIGGER MODE
*   $C0C8 = WINDOW PRESET
*   $C0C9 = ARM CAPTURE
*-------------------------------
REG_CMD  EQU $C0C3
REG_TRCH EQU $C0C6
REG_TRMD EQU $C0C7
REG_WIN  EQU $C0C8
REG_ARM  EQU $C0C9
ST_CAP   EQU $08
*-------------------------------
FILLBUF
 STY $C0C0           ; SELECT CHANNEL
 LDX #$00            ; SAMPLE INDEX
:RDLOOP
 STX $C0C1           ; SET SAMPLE ADDR
 LDA #$02
 STA $C0C3           ; SEND READ CMD
:WAIT
 LDA $C0C4           ; CHECK STATUS
 LSR                 ; BIT0 -> CARRY
 BCS :WAIT           ; LOOP IF BUSY
 LDA $C0C2           ; READ DATA
 STA TMPBUF,X        ; STORE IN BUFFER
 INX
 CPX #$26            ; 38 SAMPLES
 BNE :RDLOOP
 LDA #$02
 STA $C0C4           ; SIGNAL READY
 RTS


GETSMPL MAC
 LDA #<]1
 STA SMPLPTR
 LDA #>]1
 STA SMPLPTR+1
 JSR CALCHAN
 <<<
*
*-------------------------------
*SETPRINT MACRO                *
*-------------------------------
*
SETPRINT MAC
 LDA #<]1 ; LINE
 STA TXTPTR
 LDA #>]1
 STA TXTPTR+1

 LDA #]2
 JSR PRINTLN
 <<<
*
*-------------------------------
* MAIN - ENTRY POINT
*-------------------------------
MAIN
 JSR HGR              ; CLEAR SCREEN + HIRES MODE
*
* INIT CURSOR MARKERS (A/B) AS UNSET
 LDA #$FF
 STA ACOL
 STA BCOL
*
*-------------------------------
* INIT CAPTURE STATE DEFAULTS
*-------------------------------
 LDA #$02             ; CHANNEL 3 (0-INDEXED)
 STA TRIGCHAN
 LDA #$00             ; RISING EDGE
 STA TRIGMODE
 LDA #$02             ; PRESET 2 (88US) - STORED AS 1-4
 STA WINPRESET
 LDA #$00             ; STATE = READY
 STA CAPSTATE
 STA WINSEL           ; NOT IN WINDOW SELECT
*
*-------------------------------
* INIT FPGA / WAIT FOR READY
*-------------------------------
* WRITE CAPTURE CONFIG TO FPGA
 LDA TRIGCHAN
 STA REG_TRCH
 LDA TRIGMODE
 STA REG_TRMD
 LDA WINPRESET
 SEC
 SBC #$01            ; CONVERT 1-4 TO 0-3
 STA REG_WIN
* GET STRETCH FROM WINDOW PRESET
 LDX WINPRESET
 DEX                  ; 1-4 -> 0-3
 LDA WINSTRCH,X
 STA SMPRATE          ; STORE IN ZP
 STA $C0C5            ; CONFIG: SET STRETCH
* DON'T REGENERATE AT STARTUP - NO VALID CAPTURE DATA YET
* USER MUST ARM (SPACEBAR) TO CAPTURE FIRST
*
* CLEAR TEXT AREA + SHOW ALL LINES
 JSR CLRTXT
 JSR SHOWSTAT        ; LINE 0
 JSR SHOWWIN         ; LINE 2
*
*-------------------------------
* SKIP DRAWING CHANNELS - NO DATA YET
*-------------------------------
*
*-------------------------------
* DRAW TOP BORDER
*-------------------------------
*
 LDA #$7F
 LDX #$00
 JSR DRAWBRD
 LDX #$01
 JSR DRAWBRD ; A SHOULD STILL HAVE #$7F

 LDA #$01
 LDX #$02
 JSR DRAWBRD
 LDX #$03
 JSR DRAWBRD ; A SHOULD STILL HAVE #$01
*
*-------------------------------
* DRAW SIDE BORDERS
*-------------------------------
*
 LDX #$02
BORDLR
 LDA HI,X
 STA HIGH
 LDA LO,X
 STA LOW
 LDA #$03
 LDY #$00
 STA (LOW),Y
 LDA #$60
 LDY #$27
 STA (LOW),Y
 INX
 CPX #$9F
 BNE BORDLR
*
*-------------------------------
* DRAW BOTTOM BORDER
*-------------------------------
*
 LDA #$7F
 LDX #$9F
 JSR DRAWBRD
 LDX #$9E
 JSR DRAWBRD ; A SHOULD STILL HAVE #$7F

 LDA #$01
 LDX #$9D
 JSR DRAWBRD
 LDX #$9C
 JSR DRAWBRD ; A SHOULD STILL HAVE #$01
*
*-------------------------------
* TODO FIX CORNERS
*-------------------------------
*
*-------------------------------
* DRAW CURSOR
*-------------------------------
 LDA #$14 ; COL 20
 STA CURCOL

 LDA #$01 ; BIT 1
 STA CURBIT

 JSR CALCSAMP
 LDA #<S1CUR
 STA CVTPTR
 LDA #>S1CUR
 STA CVTPTR+1
 JSR CONVTIME5
 >>> SETPRINT.STAT1;1
 LDX CURBIT
 LDA BITMASKS,X
 STA CURMASK
 JSR DRAWCUR
*
 JMP MAINLOOP
*
********************************
*
*------------------------
* SUBROUTINES
*-------------------------------
*
QUIT STA $C051
 STA $C054
 RTS
*
CLRTXT LDA #$A0
 LDX #39
:LOOPM STA $650,X
 STA $6D0,X
 STA $750,X
 STA $7D0,X
 DEX
 BPL :LOOPM
 STA $C055           ; SWITCH TO AUX
 LDX #39
:LOOPA STA $650,X
 STA $6D0,X
 STA $750,X
 STA $7D0,X
 DEX
 BPL :LOOPA
 STA $C054           ; BACK TO MAIN
 RTS
*
PRINTLN TAX
 LDA TXTLO,X
 STA STAUX+1
 STA STMAIN+1
 LDA TXTHI,X
 STA STAUX+2
 STA STMAIN+2

 LDY #$00
 LDX #$00
PRLOOP LDA (TXTPTR),Y
 BEQ PRDONE
 ORA #$80
 STA $C055
STAUX STA $FFFF,X
 INY

 LDA (TXTPTR),Y
 BEQ PRDONE2
 ORA #$80
 STA $C054
STMAIN STA $FFFF,X
 INY
 INXO
 CPX #40
 BCC PRLOOP

PRDONE2 STA $C054
PRDONE STA $C054
 RTS
*
*-------------------------------
* MAIN LOOP
*-------------------------------
*
MAINLOOP LDA $C000
 BPL MAINLOOP        ; NO KEYBOARD
 STA $C010           ; STROBE
*
* CHECK WINDOW SELECT MODE FIRST
 LDX WINSEL
 BEQ :NORMKEY        ; NOT IN WIN SELECT MODE
* WINDOW SELECT MODE - CHECK 1-4
 CMP #$B1            ; '1'
 BEQ :GOWIN1
 CMP #$B2            ; '2'
 BEQ :GOWIN2
 CMP #$B3            ; '3'
 BEQ :GOWIN3
 CMP #$B4            ; '4'
 BEQ :GOWIN4
* ANY OTHER KEY CANCELS WIN SELECT
 LDX #$00
 STX WINSEL
 JSR SHOWSTAT
 JMP MAINLOOP
:GOWIN1 LDA #$01
 JMP SETWIN
:GOWIN2 LDA #$02
 JMP SETWIN
:GOWIN3 LDA #$03
 JMP SETWIN
:GOWIN4 LDA #$04
 JMP SETWIN
*
:NORMKEY
 CMP #$9B            ; ESC
 BEQ :GOESC
*
 CMP #$88            ; LEFT
 BEQ :GOLFT
*
 CMP #$95            ; RIGHT
 BEQ :GORIT
*
 CMP #$C1            ; 'A'
 BEQ :GOA
*
 CMP #$C2            ; 'B'
 BEQ :GOB
*
 CMP #$C3            ; 'C'
 BEQ :GOC
*
 CMP #$D2            ; 'R'
 BEQ :GOR
*
 CMP #$D7            ; 'W' - WINDOW SELECT
 BEQ :GOW
*
 CMP #$C9            ; 'I' - RISING EDGE
 BEQ :GOI
*
 CMP #$CC            ; 'L' - FALLING EDGE
 BEQ :GOL
*
 CMP #$A0            ; SPACEBAR - ARM
 BEQ :GOARM
*
 CMP #$D8            ; 'X' - SOFT RESET
 BEQ :GOX
*
* CHECK FOR 1-8 (TRIGGER CHANNEL)
 CMP #$B1            ; '1'
 BCC :NOTCH          ; < '1'
 CMP #$B9            ; > '8'?
 BCS :NOTCH
 JMP SETTRIG         ; SET TRIGGER CHANNEL
:NOTCH
 JMP MAINLOOP
*
:GOESC JMP QUIT
:GOLFT JMP GOLEFT
:GORIT JMP GORIGHT
:GOA JMP DROPA
:GOB JMP DROPB
:GOC JMP CLEARAB
:GOR JMP REGEN
:GOW JMP WINMODE
:GOI JMP SETRISE
:GOL JMP SETFALL
:GOARM JMP ARMCAP
:GOX JMP SOFTRST
*
*-------------------------------
* LEFT CURSOR
*-------------------------------
*
MVLEFT LDA CURBIT
 BNE LEFTBIT
 LDA CURCOL
 CMP #$01 ; EDGE?
 BEQ :BLOCK ; BEEP + DONT MOVE
 DEC CURCOL
 LDA #$06 ; BIT 6
 STA CURBIT
 JMP UPDMASK
:BLOCK JMP BLOCKED

LEFTBIT LDA $C061 ; OPEN APPLE?
 BMI :SKIP10
 DEC CURBIT ; SINGLE
 JMP UPDMASK
:SKIP10 TXA ; SAVE X
 PHA
 LDX #10
:LOOP LDA CURBIT
 BEQ :DONE ; HIT BIT 0, STOP
 DEC CURBIT
 DEX
 BNE :LOOP
:DONE PLA ; RESTORE X
 TAX
 JMP UPDMASK

GOLEFT JSR DRAWCUR ; ERASE
 JSR MVLEFT
 JSR DRAWCUR ; DRAW
 JMP CURUPD
*
*-------------------------------
* RIGHT CURSOR
*-------------------------------
*
MVRIGHT LDA CURBIT
 CMP #$06 ; BIT 6?
 BNE RIGHTBIT
 LDA CURCOL
 CMP #$26 ; EDGE?
 BEQ :BLOCK
 INC CURCOL
 LDA #$00
 STA CURBIT
 JMP UPDMASK
:BLOCK JMP BLOCKED

RIGHTBIT LDA $C061 ; OPEN APPLE?
 BMI :SKIP10
 INC CURBIT ; SINGLE
 JMP UPDMASK
:SKIP10 TXA ; SAVE X
 PHA
 LDX #10
:LOOP LDA CURBIT
 CMP #$06 ; HIT BIT 6?
 BEQ :DONE ; STOP
 INC CURBIT
 DEX
 BNE :LOOP
:DONE PLA ; RESTORE X
 TAX
 JMP UPDMASK

GORIGHT JSR DRAWCUR ; ERASE
 JSR MVRIGHT
 JSR DRAWCUR ; DRAW
 JMP CURUPD
*
*-------------------------------
* CURSOR UPDATE AFTER MOVE
*-------------------------------
*
CURUPD JSR CALCSAMP
 LDA #<S1CUR
 STA CVTPTR
 LDA #>S1CUR
 STA CVTPTR+1
 JSR CONVTIME5
 >>> SETPRINT.STAT1;1
 JMP MAINLOOP
*
*-------------------------------
* DROP MARKER A
*-------------------------------
*
DROPA LDA ACOL
 CMP #$FF ; NOT SET?
 BEQ :SETNEW
* ERASE OLD MARKER
 LDA CURCOL
 PHA
 LDA CURMASK
 PHA
 LDA ACOL
 STA CURCOL
 LDX ABIT
 LDA BITMASKS,X
 STA CURMASK
 JSR DRAWCUR
* RESTORE
 PLA
 STA CURMASK
 PLA
 STA CURCOL
:SETNEW LDA CURCOL
 STA ACOL
 LDA CURBIT
 STA ABIT
 JSR DRAWCUR
* COPY TIME (5 CHARS) + CHECK DELTA
 LDX #$04
:CPYA LDA S1CUR,X
 STA S1ATIME,X
 DEX
 BPL :CPYA
* CALC DELTA IF B IS SET
 LDA BCOL
 CMP #$FF
 BEQ :NODLTA
 JSR CALCDELTA
:NODLTA
 >>> SETPRINT.STAT1;1
 JMP MAINLOOP
*
*-------------------------------
* DROP MARKER B
*-------------------------------
*
DROPB LDA BCOL
 CMP #$FF ; NOT SET?
 BEQ :SETNEW
* ERASE OLD MARKER
 LDA CURCOL
 PHA
 LDA CURMASK
 PHA
 LDA BCOL
 STA CURCOL
 LDX BBIT
 LDA BITMASKS,X
 STA CURMASK
 JSR DRAWCUR
* RESTORE
 PLA
 STA CURMASK
 PLA
 STA CURCOL
:SETNEW LDA CURCOL
 STA BCOL
 LDA CURBIT
 STA BBIT
 JSR DRAWCUR
* COPY TIME (5 CHARS) + CHECK DELTA
 LDX #$04
:CPYB LDA S1CUR,X
 STA S1BTIME,X
 DEX
 BPL :CPYB
* CALC DELTA IF A IS SET
 LDA ACOL
 CMP #$FF
 BEQ :NODLTB
 JSR CALCDELTA
:NODLTB
 >>> SETPRINT.STAT1;1
 JMP MAINLOOP
*
*-------------------------------
* CLEAR MARKERS A + B
*-------------------------------
*
CLEARAB JSR ERASEMRK
 JSR CLRSTATE
 JMP MAINLOOP
*
*-------------------------------
* ERASE MARKER GRAPHICS (SUBROUTINE)
*-------------------------------
*
ERASEMRK LDA CURCOL
 PHA
 LDA CURMASK
 PHA
* ERASE A IF SET
 LDA ACOL
 CMP #$FF
 BEQ :CLRB
 STA CURCOL
 LDX ABIT
 LDA BITMASKS,X
 STA CURMASK
 JSR DRAWCUR
* ERASE B IF SET
:CLRB LDA BCOL
 CMP #$FF
 BEQ :DONE
 STA CURCOL
 LDX BBIT
 LDA BITMASKS,X
 STA CURMASK
 JSR DRAWCUR
* RESTORE
:DONE PLA
 STA CURMASK
 PLA
 STA CURCOL
 RTS
*
*-------------------------------
* CLEAR MARKER STATE (SUBROUTINE)
*-------------------------------
*
CLRSTATE LDA #$FF
 STA ACOL
 STA BCOL
* RESET TIME STRINGS (5 CHARS EACH)
 LDA #$2D           ; '-'
 LDX #$04
:CLRT STA S1ATIME,X
 STA S1BTIME,X
 STA S1DELTA,X
 DEX
 BPL :CLRT
 >>> SETPRINT.STAT1;1
 RTS
*
*-------------------------------
* CONVERT ASCII HEX TO VALUE
* IN: A = ASCII CHAR (HI BIT SET)
* OUT: A = 0-15, C=0 IF VALID
*      C=1 IF INVALID
*-------------------------------
*
HEXVAL AND #$7F ; STRIP HI BIT
 CMP #$30 ; < '0'?
 BCC :BAD
 CMP #$3A ; <= '9'?
 BCC :DIGIT
 CMP #$41 ; < 'A'?
 BCC :BAD
 CMP #$47 ; <= 'F'?
 BCS :BAD
 SEC
 SBC #$37 ; 'A'-10
 CLC
 RTS
:DIGIT SEC
 SBC #$30 ; '0'
 CLC
 RTS
:BAD SEC
 RTS
*
*-------------------------------
* NIBBLE TO ASCII HEX
* IN: A = 0-15
* OUT: A = ASCII CHAR (HI BIT SET)
*-------------------------------
*
HEXASC CMP #$0A
 BCC :ISDIG
 CLC
 ADC #$37 ; 'A'-10
 ORA #$80
 RTS
:ISDIG CLC
 ADC #$30 ; '0'
 ORA #$80
 RTS
*
*-------------------------------
* REGENERATE SIGNALS
*-------------------------------
*
REGEN
* CLEAR MARKERS
 JSR ERASEMRK
 JSR CLRSTATE
* ERASE MAIN CURSOR
 JSR DRAWCUR
* RESTART CAPTURE WITH CURRENT RATE
 LDA SMPRATE
 STA $C0C5
 LDA #$10
 STA $C0C3 ; CMD: START CAPTURE
:WRDY LDA $C0C4
 AND #$02
 BEQ :WRDY
* REDRAW ALL 8 CHANNELS
 JSR DRAWCHANS
* RESTORE LEFT BORDER
 LDX #$02
:BRDLP LDA HI,X
 STA HIGH
 LDA LO,X
 STA LOW
 LDA #$03
 LDY #$00
 STA (LOW),Y
 INX
 CPX #$9F
 BNE :BRDLP
* REDRAW MAIN CURSOR
 JSR DRAWCUR
 JMP MAINLOOP
*
*-------------------------------
* WINDOW SELECT MODE
*-------------------------------
*
WINMODE
 LDA #$01
 STA WINSEL          ; SET FLAG
 JSR SHOWSTAT        ; UPDATE STATUS (SHOWS "?")
 JMP MAINLOOP
*
*-------------------------------
* SET WINDOW PRESET
* IN: A = PRESET (1-4)
*-------------------------------
*
SETWIN
 STA WINPRESET
 LDA #$00
 STA WINSEL          ; CLEAR WIN SELECT MODE
* WRITE TO FPGA (CONVERT 1-4 TO 0-3)
 LDA WINPRESET
 SEC
 SBC #$01
 STA REG_WIN
* UPDATE STRETCH FACTOR
 LDX WINPRESET
 DEX                 ; 1-4 -> 0-3
 LDA WINSTRCH,X
 STA SMPRATE
 STA $C0C5           ; FPGA STRETCH REG
* RESET STATE TO READY
 LDA #$00
 STA CAPSTATE
* CLEAR MARKERS ON WINDOW CHANGE
 JSR ERASEMRK
 JSR CLRSTATE
* UPDATE DISPLAY
 JSR SHOWSTAT
 JSR SHOWWIN
 JMP MAINLOOP
*
*-------------------------------
* SET TRIGGER CHANNEL
* IN: A = ASCII '1'-'8'
*-------------------------------
*
SETTRIG
 SEC
 SBC #$B1            ; '1' -> 0, '8' -> 7
 STA TRIGCHAN
 STA REG_TRCH        ; WRITE TO FPGA
* RESET STATE TO READY
 LDA #$00
 STA CAPSTATE
* UPDATE STATUS LINE
 JSR SHOWSTAT
 JMP MAINLOOP
*
*-------------------------------
* SET TRIGGER MODE - RISING
*-------------------------------
*
SETRISE
 LDA #$00
 STA TRIGMODE
 STA REG_TRMD        ; WRITE TO FPGA
* RESET STATE
 LDA #$00
 STA CAPSTATE
 JSR SHOWSTAT
 JMP MAINLOOP
*
*-------------------------------
* SET TRIGGER MODE - FALLING
*-------------------------------
*
SETFALL
 LDA #$01
 STA TRIGMODE
 STA REG_TRMD        ; WRITE TO FPGA
* RESET STATE
 LDA #$00
 STA CAPSTATE
 JSR SHOWSTAT
 JMP MAINLOOP
*
*-------------------------------
* SOFT RESET FPGA STATE MACHINE
*-------------------------------
*
SOFTRST
 LDA #$FF            ; SOFT RESET COMMAND
 STA REG_CMD         ; WRITE TO CMD REGISTER
* SMALL DELAY FOR FPGA TO PROCESS
 LDX #$10
:DELAY DEX
 BNE :DELAY
* RESET LOCAL STATE
 LDA #$00
 STA CAPSTATE
 JSR SHOWSTAT
* SHOW CONFIRMATION (80-COL MODE)
 LDY #$00            ; BYTE OFFSET
 LDX #$00            ; CHAR INDEX
:PRMSG LDA RSTMSG,X
 BEQ :DONE
 ORA #$80
 PHA                 ; SAVE CHAR
 TXA
 AND #$01            ; ODD OR EVEN?
 BNE :OMAIN
* EVEN CHAR - WRITE TO AUX
 STA $C055           ; PAGE2 ON = AUX
 PLA
 STA $07D0,Y
 STA $C054           ; PAGE2 OFF = MAIN
 JMP :NEXT
:OMAIN
* ODD CHAR - WRITE TO MAIN
 PLA
 STA $07D0,Y
 INY                 ; INC BYTE OFFSET AFTER ODD
:NEXT INX
 BNE :PRMSG
:DONE JMP MAINLOOP
*
RSTMSG ASC "RESET: OK"
 HEX 00
*
*-------------------------------
* ARM CAPTURE AND WAIT
*-------------------------------
*
ARMCAP
* WRITE CONFIG TO FPGA (ENSURE CURRENT)
 LDA TRIGCHAN
 STA REG_TRCH
 LDA TRIGMODE
 STA REG_TRMD
 LDA WINPRESET
 SEC
 SBC #$01            ; CONVERT 1-4 TO 0-3
 STA REG_WIN
* DERIVE AND SET STRETCH
 LDX WINPRESET
 DEX
 LDA WINSTRCH,X
 STA $C0C5
* ARM THE CAPTURE
 LDA #$01
 STA REG_ARM
* UPDATE STATE TO ARMED
 LDA #$01
 STA CAPSTATE
* CLEAR RESET MESSAGE (IF ANY)
 LDA #$A0            ; SPACE
 LDY #$04            ; 5 BYTES = 10 CHARS
:CLRST STA $C055          ; AUX
 STA $07D0,Y
 STA $C054           ; MAIN
 STA $07D0,Y
 DEY
 BPL :CLRST
 JSR SHOWSTAT
*
* POLL FOR CAPTURE COMPLETE
:WAITCAP
 LDA $C000           ; CHECK FOR ESC
 CMP #$9B
 BEQ :ABORT
 LDA $C0C4           ; READ STATUS
 AND #ST_CAP         ; BIT 3
 BEQ :WAITCAP
*
* CAPTURE COMPLETE - REGENERATE
 LDA #$10
 STA $C0C3           ; CMD: REGENERATE
:WAITRDY
 LDA $C0C4
 AND #$02            ; BIT 1 = READY
 BEQ :WAITRDY
*
* UPDATE STATE TO CAPTURED
 LDA #$02
 STA CAPSTATE
 JSR SHOWSTAT
*
* CLEAR MARKERS AND REDRAW
 JSR ERASEMRK
 JSR CLRSTATE
 JSR DRAWCUR         ; ERASE CURSOR
 JSR DRAWCHANS
* RESTORE LEFT BORDER
 LDX #$02
:BRDLP LDA HI,X
 STA HIGH
 LDA LO,X
 STA LOW
 LDA #$03
 LDY #$00
 STA (LOW),Y
 INX
 CPX #$9F
 BNE :BRDLP
* REDRAW CURSOR
 JSR DRAWCUR
 JMP MAINLOOP
*
:ABORT
 STA $C010           ; STROBE
 LDA #$00
 STA CAPSTATE
 JSR SHOWSTAT
 JMP MAINLOOP
*
*-------------------------------
* SHOW STATUS LINE
* FORMAT: TRIG:CHn MODE  WIN:XXXus [STATE]
*-------------------------------
*
SHOWSTAT
* BUILD CHANNEL NUMBER (1-8)
 LDA TRIGCHAN
 CLC
 ADC #$31            ; 0-7 -> '1'-'8'
 STA S0TRGCH
*
* BUILD MODE STRING (4 CHARS)
 LDA TRIGMODE
 BNE :ISFALL
 LDX #$00
:CPRIS LDA STRRISE,X
 STA S0TRGMD,X
 INX
 CPX #$04
 BNE :CPRIS
 JMP :DOSTATE
:ISFALL
 LDX #$00
:CPFAL LDA STRFALL,X
 STA S0TRGMD,X
 INX
 CPX #$04
 BNE :CPFAL
*
:DOSTATE
* CHECK WIN SELECT MODE
 LDA WINSEL
 BEQ :NORMST
* WINDOW SELECT - SHOW "WIN??  "
 LDX #$00
:CPWIN LDA STR7WIN,X
 STA S0STATE,X
 INX
 CPX #$07
 BNE :CPWIN
 JMP :PRINT
*
:NORMST
* NORMAL STATE DISPLAY
 LDA CAPSTATE
 BEQ :ISREADY
 CMP #$01
 BEQ :ISARMED
* CAPTURED
 LDX #$00
:CPCAP LDA STR7CAP,X
 STA S0STATE,X
 INX
 CPX #$07
 BNE :CPCAP
 JMP :PRINT
:ISREADY
 LDX #$00
:CPRDY LDA STR7RDY,X
 STA S0STATE,X
 INX
 CPX #$07
 BNE :CPRDY
 JMP :PRINT
:ISARMED
 LDX #$00
:CPARM LDA STR7ARM,X
 STA S0STATE,X
 INX
 CPX #$07
 BNE :CPARM
*
:PRINT
 >>> SETPRINT.STAT0;0
 RTS
*
*-------------------------------
* CONVERT WINDOW TO 3 DIGITS
* IN: TEMP/TEMP+1 = VALUE
* OUT: S2WTIME (3 CHARS)
*-------------------------------
*
CONVWIN
 LDA TEMP
 STA WINVAL
 LDA TEMP+1
 STA WINVAL+1
* 3-DIGIT CONVERSION (RIGHT TO LEFT)
 LDX #$02            ; START WITH ONES
:LOOP LDA #$00
 STA REMAIN
 LDY #16             ; 16 BITS
:DIV ASL WINVAL
 ROL WINVAL+1
 ROL REMAIN
 LDA REMAIN
 CMP #10
 BCC :NOSUB
 SBC #10
 STA REMAIN
 INC WINVAL
:NOSUB DEY
 BNE :DIV
 LDA REMAIN
 CLC
 ADC #$30            ; ASCII '0'
 STA S2WTIME,X
:NEXT DEX
 BPL :LOOP
 RTS
*
WINVAL DS 2
*
*-------------------------------
* SHOWWIN - DISPLAY LINE 2
* WINDOW ZOOM AND PAGE INFO
*-------------------------------
*
SHOWWIN
* ZOOM NUMBER (1-4)
 LDA WINPRESET
 CLC
 ADC #$30            ; 1-4 -> '1'-'4'
 STA S2ZOOM
*
* WINDOW TIME
 LDX WINPRESET
 DEX                 ; 1-4 -> 0-3
 LDA WINTIME,X
 STA TEMP
 LDA WINTIMEH,X
 STA TEMP+1
 JSR CONVWIN
*
* PAGE NUMBERS (STATIC FOR NOW)
 LDA PAGECUR
 JSR CONVPG2CUR
 LDA PAGETOT
 JSR CONVPG2TOT
*
 >>> SETPRINT.STAT2;2
 RTS
*
*-------------------------------
* CONVPG2CUR - 2-DIGIT TO S2PGCUR
* IN: A = VALUE (1-99)
*-------------------------------
*
CONVPG2CUR
 LDX #$00
 SEC
:TENS SBC #10
 BMI :DONE
 INX
 JMP :TENS
:DONE ADC #10
 PHA
 TXA
 CLC
 ADC #$30
 STA S2PGCUR
 PLA
 CLC
 ADC #$30
 STA S2PGCUR+1
 RTS
*
*-------------------------------
* CONVPG2TOT - 2-DIGIT TO S2PGTOT
* IN: A = VALUE (1-99)
*-------------------------------
*
CONVPG2TOT
 LDX #$00
 SEC
:TENS SBC #10
 BMI :DONE
 INX
 JMP :TENS
:DONE ADC #10
 PHA
 TXA
 CLC
 ADC #$30
 STA S2PGTOT
 PLA
 CLC
 ADC #$30
 STA S2PGTOT+1
 RTS
*
*-------------------------------
* CURSOR UPDATE
*-------------------------------
*
UPDMASK LDX CURBIT
 LDA BITMASKS,X
 STA CURMASK
 RTS

BLOCKED JMP BELL

*
DRAWCUR LDX #$00
DCLOOP LDA HI,X
 STA HIGH
 LDA LO,X
 STA LOW
 LDY CURCOL
 LDA (LOW),Y
 EOR CURMASK
 STA (LOW),Y
 INX
 CPX #$A0
 BNE DCLOOP
 RTS
*
*-------------------------------
* CALC PRINT TIME              *
*-------------------------------
*
CALCSAMP LDA CURCOL
 SEC
 SBC #$01 ; 0 -37
 STA TEMP2 ; SAVE

 LDA #$00
 STA VALMID ; CLEAR HIGH BYTE
 LDA TEMP2
 ASL ; X 2
 ROL VALMID
 ASL  ; X 4
 ROL VALMID
 ASL  ; X 8
 ROL VALMID
 STA VALLO

 ; SUB (COL-1)
 LDA VALLO
 SEC
 SBC TEMP2
 STA VALLO
 LDA VALMID
 SBC #$00 ; BORROW
 STA VALMID

 ; ADD CURBIT
 LDA VALLO
 CLC
 ADC CURBIT
 STA VALLO
 LDA VALMID
 ADC #$00
 STA VALMID

 LDA #$00
 STA VALHI

 ; BUFFER OFFSET
 LDA VALLO
 CLC
 ADC BUFLO
 STA VALLO
 LDA VALMID
 ADC BUFMID
 STA VALMID
 LDA VALHI
 ADC BUFHI
 STA VALHI
*
* DIVIDE BY SMPRATE FOR MICROSECONDS
 JSR DIV16BY8
 LDA #$00
 STA VALHI
 RTS
*
TEMP2 DS 1
*
*-------------------------------
* DIV16BY8 - 16-BIT / 8-BIT    *
* IN: VALLO:VALMID = DIVIDEND  *
*     SMPRATE = DIVISOR        *
* OUT: VALLO:VALMID = QUOTIENT *
*      REMAIN = REMAINDER      *
*-------------------------------
*
DIV16BY8 LDA #$00
 STA REMAIN
 LDY #16           ; 16 BITS
:DLOOP ASL VALLO
 ROL VALMID
 ROL REMAIN
 LDA REMAIN
 CMP SMPRATE
 BCC :NOSUB
 SBC SMPRATE
 STA REMAIN
 INC VALLO
:NOSUB DEY
 BNE :DLOOP
 RTS
*
*-------------------------------
* CONVTIME5 - 16-BIT TO 5 ASCII*
* IN: VALLO:VALMID = VALUE     *
*     CVTPTR = TARGET ADDRESS  *
* OUT: 5 ASCII DIGITS AT TARGET*
*-------------------------------
*
CONVTIME5 LDY #$04       ; 5 DIGITS (4,3,2,1,0)
:LOOP LDA #$00
 STA REMAIN
 LDX #16
:DIV ASL VALLO
 ROL VALMID
 ROL REMAIN
 LDA REMAIN
 CMP #10
 BCC :NOSUB
 SBC #10
 STA REMAIN
 INC VALLO
:NOSUB DEX
 BNE :DIV
 LDA REMAIN
 CLC
 ADC #$B0           ; ASCII '0' + HI BIT
 STA (CVTPTR),Y
 DEY
 BPL :LOOP
 RTS
*
*-------------------------------
* CALCDELTA - |TIME_A - TIME_B|*
* REQUIRES: ACOL/BCOL != $FF   *
* WRITES RESULT TO S1DELTA     *
*-------------------------------
*
CALCDELTA
* CALC PIXEL_A = (ACOL-1)*7 + ABIT
 LDA ACOL
 SEC
 SBC #$01
 STA TEMP2
 LDA #$00
 STA PIXA+1
 LDA TEMP2
 ASL
 ROL PIXA+1
 ASL
 ROL PIXA+1
 ASL
 ROL PIXA+1
 SEC
 SBC TEMP2
 STA PIXA
 LDA PIXA+1
 SBC #$00            ; PROPAGATE BORROW
 STA PIXA+1
 LDA PIXA
 CLC
 ADC ABIT
 STA PIXA
 LDA PIXA+1
 ADC #$00
 STA PIXA+1
*
* CALC PIXEL_B = (BCOL-1)*7 + BBIT
 LDA BCOL
 SEC
 SBC #$01
 STA TEMP2
 LDA #$00
 STA PIXB+1
 LDA TEMP2
 ASL
 ROL PIXB+1
 ASL
 ROL PIXB+1
 ASL
 ROL PIXB+1
 SEC
 SBC TEMP2
 STA PIXB
 LDA PIXB+1
 SBC #$00            ; PROPAGATE BORROW
 STA PIXB+1
 LDA PIXB
 CLC
 ADC BBIT
 STA PIXB
 LDA PIXB+1
 ADC #$00
 STA PIXB+1
*
* CALC |PIXB - PIXA|
 LDA PIXB+1
 CMP PIXA+1
 BCC :AGTB
 BNE :BGTEA
 LDA PIXB
 CMP PIXA
 BCC :AGTB
:BGTEA
* B >= A: RESULT = B - A
 LDA PIXB
 SEC
 SBC PIXA
 STA VALLO
 LDA PIXB+1
 SBC PIXA+1
 STA VALMID
 JMP :DODIV
:AGTB
* A > B: RESULT = A - B
 LDA PIXA
 SEC
 SBC PIXB
 STA VALLO
 LDA PIXA+1
 SBC PIXB+1
 STA VALMID
*
:DODIV JSR DIV16BY8
*
* WRITE TO S1DELTA
 LDA #<S1DELTA
 STA CVTPTR
 LDA #>S1DELTA
 STA CVTPTR+1
 JSR CONVTIME5
 RTS
*
*-------------------------------
* DRAW ALL 8 CHANNELS          *
*-------------------------------
*
DRAWCHANS
 LDY #$00
:CHLOOP
 STY CHANSAVE         ; SAVE CHANNEL #
 JSR FILLBUF          ; READ SAMPLES FROM FPGA
* PROCESS SAMPLES -> ROW1/TRANS/ROW8 BUFS
 LDA #<TMPBUF
 STA SMPLPTR
 LDA #>TMPBUF
 STA SMPLPTR+1
 JSR CALCHAN
* GET STARTING HIRES LINE FOR CHANNEL
 LDY CHANSAVE
 LDA CHANLINES,Y
 STA LINENUM
* DRAW ROW1 (TOP EDGE)
 LDX LINENUM
 JSR DCROW1
* DRAW 5 TRANSITION LINES (MIDDLE)
 LDA #$05
 STA TEMP
:TRLOOP
 INC LINENUM
 LDX LINENUM
 JSR DCTRANS
 DEC TEMP
 BNE :TRLOOP
* DRAW ROW8 (BOTTOM EDGE)
 INC LINENUM
 LDX LINENUM
 JSR DCROW8
* NEXT CHANNEL
 LDY CHANSAVE
 INY
 CPY #$08
 BNE :CHLOOP
 RTS
*
*-------------------------------
* DRAW LOOPS                   *
* LDX BEFORE CALLING           *
*-------------------------------
*
DRAWBRD PHA  ;STASH THE VAL TO WRITE
 LDA HI,X
 STA HIGH
 LDA LO,X
 STA LOW
 LDY #$00
 PLA  ; RESTORE THE VALUE TO WRITE
]DRAW STA (LOW),Y
 INY
 CPY #NUMCOLS+2 ; TO THE END
 BNE ]DRAW
 RTS
*
*-------------------------------
*DRAW CHANNEL - LOAD X BEFORE  *
*-------------------------------
*
DCROW1 LDA #<ROW1BUF
 STA BUFFPTR
 LDA #>ROW1BUF
 STA BUFFPTR+1
 JMP DRCH
*
DCTRANS LDA #<TRANSBUF
 STA BUFFPTR
 LDA #>TRANSBUF
 STA BUFFPTR+1
 JMP DRCH
*
DCROW8 LDA #<ROW8BUF
 STA BUFFPTR
 LDA #>ROW8BUF
 STA BUFFPTR+1
* FALL THROUGH TO DRCH
*
DRCH LDA HI,X
 STA HIGH
 LDA LO,X
 STA LOW
 LDY #$00
]DRAW LDA (BUFFPTR),Y
 STA (LOW),Y
 INY
 CPY #NUMCOLS+1
 BNE ]DRAW
 RTS
*
*-------------------------------
* CALC LOOP                    *
*-------------------------------
*
CALCHAN LDA #$00
 STA PRVBIT ; INIT PREV TO 0
 LDY #$00 ; COL COUNT
CALCLOOP
 LDA (SMPLPTR),Y ; GET SAMPLE
 STA CURSMPL ; SAVE
;CALC TRANSITIONS
;TRANS = SAMPLE EOR ((SAMPLE ASL)
;            AND #$7E ORA PRVBIT)
 ASL ; SHIFT LEFT
 AND #$7E ; CLEAR BITS 0 & 7
 ORA PRVBIT ; BRING IN PREV BIT 6
 EOR CURSMPL ; XOR W/ ORIG = TRANS
 STA TRANS
 STA TRANSBUF,Y ; STORE TRANSITIONS
; CALC ROW1 = SAMPLE ORA TRANS
 LDA CURSMPL
 ORA TRANS
 STA ROW1BUF,Y
; CALC ROW8 = !SAMPLE ORA TRANS
 LDA CURSMPL
 EOR #$7F ;INVERT ONLY 7 BITS
 ORA TRANS
 STA ROW8BUF,Y
; SAVE BIT 6 FOR NEXT COL PRVBIT
 LDA CURSMPL
 AND #$40 ; GET BIT 6
 BEQ SAVEPREV ; IF 0, STORE 0
 LDA #$01 ; IF SET, STORE 1
SAVEPREV STA PRVBIT
 INY
 CPY #NUMCOLS+1
 BNE CALCLOOP
 RTS
*
*
BITMASKS HEX 01020408102040
CHANLINES DFB $10,$1F,$2E,$3D,$4C,$5B,$6A,$79
*
*-------------------------------
* WINDOW PRESET TABLES
* PRESET 1: 38 SAMPLES, STRETCH=7, 38US
* PRESET 2: 88 SAMPLES, STRETCH=3, 88US
* PRESET 3: 133 SAMPLES, STRETCH=2, 133US
* PRESET 4: 266 SAMPLES, STRETCH=1, 266US
*-------------------------------
WINSTRCH DFB 7,3,2,1         ; STRETCH FACTORS (INDEX 0-3)
WINTIME  DFB 38,88,133,266   ; TIME IN MICROSECONDS (LOW BYTE)
WINTIMEH DFB 0,0,0,1         ; TIME HIGH BYTE (266 > 255)
*
*-------------------------------
* BUFFERS                      *
*-------------------------------
*
TMPBUF DS 38
ROW1BUF DS 40
ROW8BUF DS 40
TRANSBUF DS 40
*-------------------------------
* BUFFER OFFSET + WORKING VARS
*-------------------------------
BUFLO DFB $00
BUFMID DFB $00
BUFHI DFB $00
VALLO DS 1
VALMID DS 1
VALHI DS 1
REMAIN DS 1
*
PAGECUR DFB $01     ; CURRENT PAGE (STATIC)
PAGETOT DFB $01     ; TOTAL PAGES (STATIC)
*
*-------------------------------
* NEW 80-COLUMN STATUS STRINGS
*-------------------------------
*
* LINE 0 - STATUS (80 CHARS + NULL)
STAT0 ASC "Status: "
S0STATE ASC "READY  "
 ASC " -  Trigger: CH"
S0TRGCH ASC "3"
 ASC " "
S0TRGMD ASC "RISE"
 ASC "                                            "
 DFB $00
*
* LINE 1 - MEASUREMENTS (80 CHARS + NULL)
STAT1 ASC "Cur:"
S1CUR ASC "00000"
 ASC "us  A:"
S1ATIME ASC "-----"
 ASC "us  B:"
S1BTIME ASC "-----"
 ASC "us  Delta:"
S1DELTA ASC "-----"
 ASC "us                                "
 DFB $00
*
* LINE 2 - WINDOW/PAGING (80 CHARS + NULL)
STAT2 ASC "Window: Zoom "
S2ZOOM ASC "2"
 ASC " ("
S2WTIME ASC "088"
 ASC "us)  - Page: "
S2PGCUR ASC "01"
 ASC " of "
S2PGTOT ASC "01"
 ASC "                                        "
 DFB $00
*
* 7-CHAR STATE STRINGS
STR7RDY ASC "READY  "
STR7ARM ASC "ARMED  "
STR7CAP ASC "CAPTURE"
STR7WIN ASC "WIN??  "
*
* 4-CHAR MODE STRINGS
STRRISE ASC "RISE"
STRFALL ASC "FALL"
*
*-------------------------------
* LINE ADDRESSES               *
*-------------------------------
*
TXTLO DFB $50,$D0,$50,$D0
TXTHI DFB $06,$06,$07,$07
 PUT LINEADDR
*
********************************
********************************
